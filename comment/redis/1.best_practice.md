一、集群申请
集群命名
Squirrel 集群名需要言简意赅，长短适中，能精准的表达出所属的BG和业务含义。

集群名总长度不超过30个字符数（包括开头的"redis-"），并不少于7个字符；

只允许出现小写字母及"-"，且"-"的个数不超过3个（包括"redis-"的第一个"-"）；

集群名中不包含环境名，如qa、dev、stage、product、test等；

集群名中不包含cache、storage等无意义等；

集群名中不包含数字。



集群大小与伸缩
Squirrel 集群基于Redis Cluster，因而所有数据都保存在内存中，内存大小限制了Squirrel集群的规模无法做的太大。即使开启了持久化，其目的也仅是为了保证数据不丢，Redis无法直接从硬盘读数据。

单节点的大小不超过5G；

总节点数目不超过100个(后续该规则可能再调整)，申请集群时容量不得超过50G；

集群扩容：当集群使用率超过80%~90%时(视业务而定)，如果存储的数据全都是热数据、数据结构选型正确条件下，可以提前为集群扩容，扩容的限额也是100个节点；针对一些大业务数据可以进行拆分成多个小集群；

集群缩容：如果集群针对临时活动或者高峰进行扩容，业务回归正常后，需对集群进行缩容；

从库数量不超过3个；

集群利用率：每GB容量的QPS不少于500 ，对于低利用率集群，业务可以直接使用每一个业务线的公用Squirrel集群，或者建议直接使用MySQL或Cellar。集群申请后3个月内，若无任何应用访问（以CAT、QPS、key数量判断），DBA有权对集群进行下线回收。



合理使用集群
Squirrel 是全内存KV，内存资源相对来说是比较昂贵的，为了规范、合理、高效使用Squirrel集群，现针对每个业务线的Squirrel集群限额为10个（针对部分特殊业务线业务需求可以联系DBA配置限额），同一个小的业务线集群限额为3个。对于QPS和容量都比较少业务，推荐在同业务线（pdl）下复用已有集群，或者业务线下面的公用集群。

申请新独立集群必备条件：

QPS维度：>10W，核心数据，高并发、高流量业务；

数据量维度：>30G，业务扩展，数据不断增加，进行拆分需要独立集群；

缓存数据分层、剥离等需要独立集群；



申请Squirrel集群必须使用squirrel-client进行接入，目前支持Java/NodeJS/C++/Python/Golang。
非上述语言服务，Squirrel暂不提供接入；

如果一定要使用其他机房，业务方可自己搭建/维护Redis集群，Squirrel团队可以提供搭建咨询服务，但不帮助搭建，不承担故障责任。

二、Key-Value 设计
Key Name
Squirrel  中 Key的命名需要言简意赅、长短适中，能够表达存储的数据。   
•  Squirrel 客户端中已经规范Key的命名结构：${category}.${template}_${version} ；
•  Category 和 传入的参数 不宜过长、也不建议太短，整个Key的长度建议不超过44个字节；
•  不要包含空白字符或者转义字符（尤其是 Redis 自带的HashTag:"{}"，用了这个会导致集群节点分布不均）；

Key命名原则：1）简洁；2）高可读。

Value
Squirrel 客户端对不同的数据结构的Value大小都有针对的限制。

•  针对不同的业务类型，选择合适的数据结构（不同的数据类型决定了不同内部编码和操作复杂度）；

•  单个Key的 Value 不宜过长/过大 ，建议String 类型不超过 512 KB，集合类型元素不超过 1万个（Squirrel 客户端限制set 单个Value不能超过1M，集合类型则限制单个元素不能超过1M）;

•  String类型 Value 大于 100KB 的数据建议开启 value 压缩，能够有效节省内存开销并且提高查询效率。具体压缩设计文档：Category压缩设计文档，压缩测试文档：大value压缩测试。

最佳实践

(1) 单个简单的Key存储的Value较大

Ⅰ 该对象需要每次整存整取：

    可以尝试将对象分拆成几个key-value， 使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平摊到多个分片(Redis实例)，降低对单个分片的影响；

Ⅱ 该对象每次只需要存取部分数据：

    可以采用I方法，也可以更改为Hash类型，每个field代表一个具体属性，使用hget、hmget来获取部分的value，使用hset、hmset来更新部分属性。    

(2) 集合类型中单个Key存储过多的元素

通过 hash 桶来拆分成多个key：

以hash为例，原先的正常存取流程是  hget(hashKey, field) ， hset(hashKey, field, value)；现在可以固定一个桶的数量，比如：10000， 每次存取的时候，先在本地计算field的hash值，模除 10000， 确定了该field落在哪个key上。

代码块
Plant Text
newHashKey  =  hashKey + ( hash(field) % 10000）;  
hset (newHashKey, field, value) ;  
hget(newHashKey, field)
​
set, zset, list 也可以类似上述做法，但有些不适合的场景，比如，要保证 lpop 的数据的确是最早push到list中去的，这个就需要一些附加的属性，或者是在 key的拼接上做一些工作（比如list按照时间来分拆）。

三、高性能设计
高效的内存管理，选择合适的数据结构


数据结构

类型

适用场景

API 接口

备注

String

String

Value 较小，模型简单的业务场景

详解：Squirrel API for Redis说明文档














Redis的 String 是二进制安全的，没有任何限制(基于此强烈不建议将任何数据都丢到String中)。

Bitmap

(1) 用户签到；
(2) 统计活跃用户。

适用存在大量活跃用户场景；

bitmap不宜太大，会产生大value。

HyperLogLog

海量数据总数统计，可以容忍一定的误差



Hash

/

(1) 适合存储对象类型数据；
(2) 海量数据，可以分桶后适用hash存储，可以更节省空间，也可以提高操作效率。

避免产生大value；

避免全量取。

List

/

(1) 顺序插入，获取最近数据。或者分页查询；
(2) 实现栈或队列。

Redis的List通过双向链表实现，头尾插入数据性能高，不适合链表中插入数据，会导致性能低效；

避免产生大value，控制队列大小；

避免全量取。

Set

/

(1) 数据去重；
(2) 集合间操作：共同好友、标签匹配等(Squirrel 客户端暂未支持)。

避免产生大value；

避免全量取。

SortedSet

Zset

排名/排行榜

避免产生大value，控制榜单、排名元素数量；

避免全量取。

GEO

地理位置信息





最佳实践

(1) String 类型优化为 Hash

     Ⅰ 大量相似的String类型的Key：

         可以优化为针对相同前缀的Key划分成一个hash，即拆分成多个小的hash数据，这样就能起到内存空间优化的效果。

         减少内存占用的原理：

         ① 在Redis 中Key也是以String格式存储的，通过拆分成hash可以缩短key的长度从而节约内存空间；

         ② Redis Server 需要维护Key to Slot的映射关系，其中指针占用在Key较多的情况也会浪费较大的内存空间。

        

      

      Ⅱ Key 本身没有关联，不具备共同性：

          采用Hash 桶进行拆分， 比如现在预估key 的总数为 2亿，按照一个hash存储 100个field来算，需要 2亿 /  100  = 200W 个桶 (200W 个key占用的空间很少，2亿可能有将近 20G ) 。

          现在按照200W 固定桶分就是先计算出桶的序号   hash(123456789)   % 200W ， 这里最好保证这个 hash算法的值是个正数，否则需要调整下模除的规则。

     另建议单个hash结构最大value不超过64字节，field不超过512个(100个左右较优)，这样对内存优化有很大提升。

高效的内存管理，String 类型的Category和集合类型设置TTL
•  Redis 是全内存KV，适用于缓存场景（不适用于数据持久化或将Redis作为数据存储的场景），建议所有的key都配置ttl，合理使用、自动释放内存；
•  String类型 Category 可以配置默认过期时间（如果在客户端API也调用expire()，则以API调用设置的为准  ），其他类型数据在API 中调用expire() 进行过期设置；
•  配置 key的ttl 过期的时间点尽量打散，不要在同一时刻存在大量的过期的Key(同一时刻过期Key的数据不要超过总ttl Key的25%，hz 初探)，可能会引起Redis性能抖动，高并发下导致大量请求直接到达后端数据库等，从而引起缓存雪崩。


高效的命令操作，拒绝Slowlog 和阻塞操作
•  避免O(N) 操作(比如hgetall/smembers 等操作)，如果一定要用，建议集合元素较小情况下使用，否则会阻塞其他会话操作；
•  在使用批量操作 multiget和pipeline时，尽量不要一次操作过多的数据，以防时间过长阻塞或数据量过大网络流量抖动，Squirrel 客户端对pipeline限制操作key的个数为512个，Multiget为1024；
•  注意避免产生BigKey，BigKey 读写(特别是String) 会阻塞其他会话操作、大量读写还会引起网络流量异常，进而引起性能波动，BigKey的过期和删除也会引起阻塞，还会引起分片内存倾斜、容量瓶颈等其他问题；
•  注意避免产生HotKey，HotKey 会引起某个分片的负载过高，而降低整个集群总体的负载能力和平衡性，进而影响业务的时效，产生性能瓶颈。


四、高可靠设计
架构可靠设计
•  Squirrel 后端采用Redis Cluster 原生模式，主从部署在不同机房，正常情况该模式下可以保证数据的备份和 Redis 的高可用（由于从库同步等会消耗主库性能，正常情况下建议单个分片从库个数不超过3个）；
•  如果业务数据属于核心范畴，可以将Cluster 模式部署成三机房，可以做到机房级别的容灾，具体参看：Squirrel 机房容灾方案选型；
•  尽量不要配置Redis 持久化策略，数据落盘和AOF Rewrite 均会产生额外IO影响，可能对 Redis 有性能抖动，特别是大量写的业务场景。如果非要持久化，建议非持久化和持久化数据分开存储，或直接使用Cellar、MySQL；
•  业务跨地区访问(例如：北京和上海)：
Ⅰ Keeper异地同步 ——通过配置集群组和keeper同步实现北上跨地域就近访问，具体参看：04-Squirrel_集群组_异地部署解决方案；
•  细分缓存粒度，缓存时效，缓存更新策略等技术手段来提高缓存命中率，保证缓存一致性，避免高并发下缓存穿透以及雪崩的现象。



功能可靠设计
•  Redis List 数据不能重复消费，只能作为有损队列；
•  Squirrel 客户端暂不支持pub/sub ，建议使用专业消息队列；
•  不建议使用 Redis 实现分布式锁，除非业务层面保证不出现HotKey（流量集中，无法扩容优化）注：分布式锁实现。
•  不建议使用 Redis 实现布隆过滤器，除非业务层面保证不出现BigKey（大于1MB）。


五、Squirrel 客户端参数配置
04-Java客户端参数详解

六、其他
Squirrel 服务等级协议
Squirrel服务等级协议（SLA）